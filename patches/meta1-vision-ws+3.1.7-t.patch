diff --git a/node_modules/meta1-vision-ws/lib/ApiInstances.js b/node_modules/meta1-vision-ws/lib/ApiInstances.js
index fa9aea3..3d13f47 100644
--- a/node_modules/meta1-vision-ws/lib/ApiInstances.js
+++ b/node_modules/meta1-vision-ws/lib/ApiInstances.js
@@ -1,2 +1,2 @@
 "use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.orders=exports.crypto=exports.history=exports.network=exports.db=exports.close=exports.chainId=exports.instance=exports.reset=exports.setAutoReconnect=exports.setRpcConnectionStatusCallback=void 0;var _ChainWebSocket=_interopRequireDefault(require("./ChainWebSocket")),_GrapheneApi=_interopRequireDefault(require("./GrapheneApi")),_ChainConfig=_interopRequireDefault(require("./ChainConfig"));function _interopRequireDefault(b){return b&&b.__esModule?b:{default:b}}var autoReconnect=!1,Apis=null,statusCb=null;// by default don't use reconnecting-websocket
-const setRpcConnectionStatusCallback=b=>{statusCb=b,Apis&&Apis.setRpcConnectionStatusCallback(b)};exports.setRpcConnectionStatusCallback=setRpcConnectionStatusCallback;const setAutoReconnect=b=>{autoReconnect=b};exports.setAutoReconnect=setAutoReconnect;const reset=(f="ws://localhost:8090",a,b=4e3,c,d)=>close().then(()=>(Apis=newApis(),Apis.setRpcConnectionStatusCallback(statusCb),Apis&&a&&Apis.connect(f,b,c,d),Apis));exports.reset=reset;const instance=(f="ws://localhost:8090",a,b=4e3,c,d)=>(Apis||(Apis=newApis(),Apis.setRpcConnectionStatusCallback(statusCb)),Apis&&a&&Apis.connect(f,b,c),d&&(Apis.closeCb=d),Apis);exports.instance=instance;const chainId=()=>instance().chain_id;exports.chainId=chainId;const close=async()=>{Apis&&(await Apis.close(),Apis=null)};exports.close=close;const get=d=>new Proxy([],{get:(a,e)=>(...a)=>Apis[d].exec(e,[...a])}),db=get("_db");exports.db=db;const network=get("_net");exports.network=network;const history=get("_hist");exports.history=history;const crypto=get("_crypt");exports.crypto=crypto;const orders=get("_orders");exports.orders=orders;const newApis=()=>({connect:(d,a,e={enableCrypto:!1,enableOrders:!1})=>{if(Apis.url=d,"undefined"!=typeof window&&window.location&&"https:"===window.location.protocol&&0>d.indexOf("wss://"))throw new Error("Secure domains require wss connection");Apis.ws_rpc&&(Apis.ws_rpc.statusCb=null,Apis.ws_rpc.keepAliveCb=null,Apis.ws_rpc.on_close=null,Apis.ws_rpc.on_reconnect=null),Apis.ws_rpc=new _ChainWebSocket.default(d,Apis.statusCb,a,autoReconnect,b=>{Apis._db&&!b&&Apis._db.exec("get_objects",[["2.1.0"]]).catch(()=>{})}),Apis.init_promise=Apis.ws_rpc.login("","").then(()=>{Apis._db=new _GrapheneApi.default(Apis.ws_rpc,"database"),Apis._net=new _GrapheneApi.default(Apis.ws_rpc,"network_broadcast"),Apis._hist=new _GrapheneApi.default(Apis.ws_rpc,"history"),e.enableOrders&&(Apis._orders=new _GrapheneApi.default(Apis.ws_rpc,"orders")),e.enableCrypto&&(Apis._crypt=new _GrapheneApi.default(Apis.ws_rpc,"crypto"));var c=Apis._db.init().then(()=>Apis._db.exec("get_chain_id",[]).then(b=>(Apis.chain_id=b,_ChainConfig.default.setChainId(b))));Apis.ws_rpc.on_reconnect=()=>{Apis.ws_rpc&&Apis.ws_rpc.login("","").then(()=>{Apis._db.init().then(()=>{Apis.statusCb&&Apis.statusCb("reconnect")}),Apis._net.init(),Apis._hist.init(),e.enableOrders&&Apis._orders.init(),e.enableCrypto&&Apis._crypt.init()})},Apis.ws_rpc.on_close=()=>{Apis.close().then(()=>{Apis.closeCb&&Apis.closeCb()})};let a=[c,Apis._net.init(),Apis._hist.init()];return e.enableOrders&&a.push(Apis._orders.init()),e.enableCrypto&&a.push(Apis._crypt.init()),Promise.all(a)}).catch(a=>(console.error(d,"Failed to initialize with error",a&&a.message),Apis.close().then(()=>{throw a})))},close:async()=>{Apis.ws_rpc&&1===Apis.ws_rpc.ws.readyState&&(await Apis.ws_rpc.close()),Apis.ws_rpc=null},db_api:()=>Apis._db,network_api:()=>Apis._net,history_api:()=>Apis._hist,crypto_api:()=>Apis._crypt,orders_api:()=>Apis._orders,setRpcConnectionStatusCallback:b=>Apis.statusCb=b});
\ No newline at end of file
+const setRpcConnectionStatusCallback=b=>{statusCb=b,Apis&&Apis.setRpcConnectionStatusCallback(b)};exports.setRpcConnectionStatusCallback=setRpcConnectionStatusCallback;const setAutoReconnect=b=>{autoReconnect=b};exports.setAutoReconnect=setAutoReconnect;const reset=function(){let f=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"ws://localhost:8090",a=1<arguments.length?arguments[1]:void 0,b=2<arguments.length&&arguments[2]!==void 0?arguments[2]:4e3,c=3<arguments.length?arguments[3]:void 0,d=4<arguments.length?arguments[4]:void 0;return close().then(()=>(Apis=newApis(),Apis.setRpcConnectionStatusCallback(statusCb),Apis&&a&&Apis.connect(f,b,c,d),Apis))};exports.reset=reset;const instance=function(){let f=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"ws://localhost:8090",a=1<arguments.length?arguments[1]:void 0,b=2<arguments.length&&arguments[2]!==void 0?arguments[2]:4e3,c=3<arguments.length?arguments[3]:void 0,d=4<arguments.length?arguments[4]:void 0;return Apis||(Apis=newApis(),Apis.setRpcConnectionStatusCallback(statusCb)),Apis&&a&&Apis.connect(f,b,c),d&&(Apis.closeCb=d),Apis};exports.instance=instance;const chainId=()=>instance().chain_id;exports.chainId=chainId;const close=async()=>{Apis&&(await Apis.close(),Apis=null)};exports.close=close;const get=d=>new Proxy([],{get:(a,e)=>function(){for(var a=arguments.length,c=Array(a),b=0;b<a;b++)c[b]=arguments[b];return Apis[d].exec(e,[...c])}}),db=get("_db");exports.db=db;const network=get("_net");exports.network=network;const history=get("_hist");exports.history=history;const crypto=get("_crypt");exports.crypto=crypto;const orders=get("_orders");exports.orders=orders;const newApis=()=>({connect:function(d,a){let e=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{enableCrypto:!1,enableOrders:!1};if(Apis.url=d,"undefined"!=typeof window&&window.location&&"https:"===window.location.protocol&&0>d.indexOf("wss://"))throw new Error("Secure domains require wss connection");Apis.ws_rpc&&(Apis.ws_rpc.statusCb=null,Apis.ws_rpc.keepAliveCb=null,Apis.ws_rpc.on_close=null,Apis.ws_rpc.on_reconnect=null),Apis.ws_rpc=new _ChainWebSocket.default(d,Apis.statusCb,a,autoReconnect,b=>{Apis._db&&!b&&Apis._db.exec("get_objects",[["2.1.0"]]).catch(()=>{})}),Apis.init_promise=Apis.ws_rpc.login("","").then(()=>{Apis._db=new _GrapheneApi.default(Apis.ws_rpc,"database"),Apis._net=new _GrapheneApi.default(Apis.ws_rpc,"network_broadcast"),Apis._hist=new _GrapheneApi.default(Apis.ws_rpc,"history"),e.enableOrders&&(Apis._orders=new _GrapheneApi.default(Apis.ws_rpc,"orders")),e.enableCrypto&&(Apis._crypt=new _GrapheneApi.default(Apis.ws_rpc,"crypto"));var c=Apis._db.init().then(()=>Apis._db.exec("get_chain_id",[]).then(b=>(Apis.chain_id=b,_ChainConfig.default.setChainId(b))));Apis.ws_rpc.on_reconnect=()=>{Apis.ws_rpc&&Apis.ws_rpc.login("","").then(()=>{Apis._db.init().then(()=>{Apis.statusCb&&Apis.statusCb("reconnect")}),Apis._net.init(),Apis._hist.init(),e.enableOrders&&Apis._orders.init(),e.enableCrypto&&Apis._crypt.init()})},Apis.ws_rpc.on_close=()=>{Apis.close().then(()=>{Apis.closeCb&&Apis.closeCb()})};let a=[c,Apis._net.init(),Apis._hist.init()];return e.enableOrders&&a.push(Apis._orders.init()),e.enableCrypto&&a.push(Apis._crypt.init()),Promise.all(a)}).catch(a=>(console.error(d,"Failed to initialize with error",a&&a.message),Apis.close().then(()=>{throw a})))},close:async()=>{Apis.ws_rpc&&1===Apis.ws_rpc.ws.readyState&&(await Apis.ws_rpc.close()),Apis.ws_rpc=null},db_api:()=>Apis._db,network_api:()=>Apis._net,history_api:()=>Apis._hist,crypto_api:()=>Apis._crypt,orders_api:()=>Apis._orders,setRpcConnectionStatusCallback:b=>Apis.statusCb=b});
\ No newline at end of file
diff --git a/node_modules/meta1-vision-ws/lib/ChainConfig.js b/node_modules/meta1-vision-ws/lib/ChainConfig.js
index 68a07e6..8425a73 100644
--- a/node_modules/meta1-vision-ws/lib/ChainConfig.js
+++ b/node_modules/meta1-vision-ws/lib/ChainConfig.js
@@ -1 +1 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var config={core_asset:"CORE",address_prefix:"GPH",expire_in_secs:15,expire_in_secs_proposal:86400,review_in_secs_committee:86400,networks:{META1:{core_asset:"META1TEST",address_prefix:"TEST0",chain_id:"e75f9445142dd56cb0e1fd619a95c75de6bd60cca342a21f71ffa88f65c572c3"}},/** Set a few properties for known chain IDs. */setChainId:d=>{let a=Object.entries(config.networks).find(([a,b])=>{if(b.chain_id===d)return config.network_name=a,b.address_prefix&&(config.address_prefix=b.address_prefix),!0});return a?{network_name:a[0],network:a[1]}:void console.log("Unknown chain id (this may be a testnet)",d)},reset:()=>{config.core_asset="CORE",config.address_prefix="GPH",config.expire_in_secs=15,config.expire_in_secs_proposal=86400,console.log("Chain config reset")},setPrefix:(b="GPH")=>config.address_prefix=b},_default=config;exports.default=_default;
\ No newline at end of file
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var config={core_asset:"CORE",address_prefix:"GPH",expire_in_secs:15,expire_in_secs_proposal:86400,review_in_secs_committee:86400,networks:{META1DEV:{core_asset:"META1",address_prefix:"DEV11",chain_id:"b259cf0af064c8f147764510c1aa710799a855cd0ad709f5bebb1aab37a9d99e"}},/** Set a few properties for known chain IDs. */setChainId:d=>{let a=Object.entries(config.networks).find(a=>{let[e,b]=a;if(b.chain_id===d)return config.network_name=e,b.address_prefix&&(config.address_prefix=b.address_prefix),!0});return a?{network_name:a[0],network:a[1]}:void console.log("Unknown chain id (this may be a testnet)",d)},reset:()=>{config.core_asset="CORE",config.address_prefix="GPH",config.expire_in_secs=15,config.expire_in_secs_proposal=86400,console.log("Chain config reset")},setPrefix:function(){let b=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"GPH";return config.address_prefix=b}},_default=config;exports.default=_default;
\ No newline at end of file
diff --git a/node_modules/meta1-vision-ws/lib/ChainWebSocket.js b/node_modules/meta1-vision-ws/lib/ChainWebSocket.js
index 52c423d..83ca0a7 100644
--- a/node_modules/meta1-vision-ws/lib/ChainWebSocket.js
+++ b/node_modules/meta1-vision-ws/lib/ChainWebSocket.js
@@ -1,3 +1,3 @@
-"use strict";var _isomorphicWs=_interopRequireDefault(require("isomorphic-ws"));Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;function _interopRequireDefault(b){return b&&b.__esModule?b:{default:b}}function _defineProperty(d,a,b){return a in d?Object.defineProperty(d,a,{value:b,enumerable:!0,configurable:!0,writable:!0}):d[a]=b,d}const SOCKET_DEBUG=!1,MAX_SEND_LIFE=5,MAX_RECV_LIFE=10;class ChainWebSocket{constructor(f,a,b=5e3,c=!0,d=null){_defineProperty(this,"connect",(c,a)=>new Promise((b,e)=>{this.current_reject=e,this.current_resolve=b;try{this.ws=new _isomorphicWs.default(c)}catch(a){// DISCONNECTED
-this.ws={readyState:3,close:()=>{}},e(new Error("Invalid url",c," closed"))}this.ws.onopen=this.onOpen,this.ws.onerror=this.onError,this.ws.onmessage=this.onMessage,this.ws.onclose=this.onClose,this.connectionTimeout=setTimeout(()=>{this.current_reject&&(this.current_reject=null,this.close(),e(new Error("Connection attempt timed out after "+a/1e3+"s")))},a)})),_defineProperty(this,"onOpen",()=>{clearTimeout(this.connectionTimeout),this.statusCb&&this.statusCb("open"),this.on_reconnect&&this.on_reconnect(),this.keepalive_timer=setInterval(()=>(this.recv_life--,0==this.recv_life?(console.error(this.url+" connection is dead, terminating ws"),void this.close()):void(this.send_life--,0==this.send_life&&(this.keepAliveCb&&this.keepAliveCb(this.closed),this.send_life=MAX_SEND_LIFE))),5e3),this.current_reject=null,this.current_resolve()}),_defineProperty(this,"onError",b=>{this.keepalive_timer&&(clearInterval(this.keepalive_timer),this.keepalive_timer=void 0),clearTimeout(this.connectionTimeout),this.statusCb&&this.statusCb("error"),this.current_reject&&this.current_reject(b)}),_defineProperty(this,"onMessage",b=>{this.recv_life=MAX_RECV_LIFE,this.listener(JSON.parse(b.data))}),_defineProperty(this,"onClose",()=>{this.closed=!0,this.keepalive_timer&&(clearInterval(this.keepalive_timer),this.keepalive_timer=void 0);for(var b=this.responseCbId+1;b<=this.cbId;b+=1)this.cbs[b].reject(new Error("connection closed"));this.statusCb&&this.statusCb("closed"),this._closeCb&&this._closeCb(),this.on_close&&this.on_close()}),_defineProperty(this,"call",d=>{if(1!==this.ws.readyState)return Promise.reject(new Error("websocket state error:"+this.ws.readyState));let a=d[1];if(SOCKET_DEBUG&&console.log("[ChainWebSocket] >---- call ----->  \"id\":"+(this.cbId+1),JSON.stringify(d)),this.cbId+=1,["set_subscribe_callback","subscribe_to_market","broadcast_transaction_with_callback","set_pending_transaction_callback","set_block_applied_callback"].includes(a)&&(this.subs[this.cbId]={callback:d[2][0]},d[2][0]=this.cbId),["unsubscribe_from_market","unsubscribe_from_accounts"].includes(a)){if("function"!=typeof d[2][0])throw new Error("First parameter of unsub must be the original callback");let c=d[2].splice(0,1)[0];// Find the corresponding subscription
+"use strict";var _isomorphicWs=_interopRequireDefault(require("isomorphic-ws"));Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;function _interopRequireDefault(b){return b&&b.__esModule?b:{default:b}}function _defineProperty(d,a,b){return a in d?Object.defineProperty(d,a,{value:b,enumerable:!0,configurable:!0,writable:!0}):d[a]=b,d}const SOCKET_DEBUG=!1,MAX_SEND_LIFE=5,MAX_RECV_LIFE=10;class ChainWebSocket{constructor(f,a){let b=2<arguments.length&&arguments[2]!==void 0?arguments[2]:5e3,c=!(3<arguments.length&&arguments[3]!==void 0)||arguments[3],d=4<arguments.length&&arguments[4]!==void 0?arguments[4]:null;_defineProperty(this,"connect",(c,a)=>new Promise((b,e)=>{this.current_reject=e,this.current_resolve=b;try{this.ws=new _isomorphicWs.default(c)}catch(a){// DISCONNECTED
+this.ws={readyState:3,close:()=>{}},e(new Error("Invalid url",c," closed"))}this.ws.onopen=this.onOpen,this.ws.onerror=this.onError,this.ws.onmessage=this.onMessage,this.ws.onclose=this.onClose,this.connectionTimeout=setTimeout(()=>{this.current_reject&&(this.current_reject=null,this.close(),e(new Error("Connection attempt timed out after "+a/1e3+"s")))},a)})),_defineProperty(this,"onOpen",()=>{clearTimeout(this.connectionTimeout),this.statusCb&&this.statusCb("open"),this.on_reconnect&&this.on_reconnect(),this.keepalive_timer=setInterval(()=>(this.recv_life--,0==this.recv_life?(console.error(this.url+" connection is dead, terminating ws"),void this.close()):void(this.send_life--,0==this.send_life&&(this.keepAliveCb&&this.keepAliveCb(this.closed),this.send_life=MAX_SEND_LIFE))),5e3),this.current_reject=null,this.current_resolve()}),_defineProperty(this,"onError",b=>{this.keepalive_timer&&(clearInterval(this.keepalive_timer),this.keepalive_timer=void 0),clearTimeout(this.connectionTimeout),this.statusCb&&this.statusCb("error"),this.current_reject&&this.current_reject(b)}),_defineProperty(this,"onMessage",b=>{this.recv_life=MAX_RECV_LIFE,b&&b.data&&this.listener(JSON.parse(b.data))}),_defineProperty(this,"onClose",()=>{this.closed=!0,this.keepalive_timer&&(clearInterval(this.keepalive_timer),this.keepalive_timer=void 0);for(var b=this.responseCbId+1;b<=this.cbId;b+=1)this.cbs[b].reject(new Error("connection closed"));this.statusCb&&this.statusCb("closed"),this._closeCb&&this._closeCb(),this.on_close&&this.on_close()}),_defineProperty(this,"call",d=>{if(1!==this.ws.readyState)return Promise.reject(new Error("websocket state error:"+this.ws.readyState));let a=d[1];if(SOCKET_DEBUG&&console.log("[ChainWebSocket] >---- call ----->  \"id\":"+(this.cbId+1),JSON.stringify(d)),this.cbId+=1,["set_subscribe_callback","subscribe_to_market","broadcast_transaction_with_callback","set_pending_transaction_callback","set_block_applied_callback"].includes(a)&&(this.subs[this.cbId]={callback:d[2][0]},d[2][0]=this.cbId),["unsubscribe_from_market","unsubscribe_from_accounts"].includes(a)){if("function"!=typeof d[2][0])throw new Error("First parameter of unsub must be the original callback");let c=d[2].splice(0,1)[0];// Find the corresponding subscription
 for(let b in this.subs)if(this.subs[b].callback===c){this.unsub[this.cbId]=b;break}}var e={method:"call",params:d};return e.id=this.cbId,this.send_life=MAX_SEND_LIFE,new Promise((c,a)=>{this.cbs[this.cbId]={time:new Date,resolve:c,reject:a},this.ws.send(JSON.stringify(e))})}),_defineProperty(this,"listener",d=>{SOCKET_DEBUG&&console.log("[ChainWebSocket] <---- reply ----<",JSON.stringify(d));let a=!1,e=null;"notice"===d.method&&(a=!0,d.id=d.params[0]),a?e=this.subs[d.id].callback:(e=this.cbs[d.id],this.responseCbId=d.id),e&&!a?(d.error?e.reject(d.error):e.resolve(d.result),delete this.cbs[d.id],this.unsub[d.id]&&(delete this.subs[this.unsub[d.id]],delete this.unsub[d.id])):e&&a?e(d.params[1]):console.log("Warning: unknown websocket response: ",d)}),_defineProperty(this,"login",(c,a)=>this.connect_promise.then(()=>this.call([1,"login",[c,a]]))),_defineProperty(this,"close",()=>new Promise(b=>(clearInterval(this.keepalive_timer),this.keepalive_timer=void 0,this._closeCb=()=>{b(),this._closeCb=null},this.ws?void(this.ws.terminate?this.ws.terminate():this.ws.close(),3===this.ws.readyState&&b()):(console.log("Websocket already cleared",this),b())))),this.url=f,this.statusCb=a,this.current_reject=null,this.on_reconnect=null,this.closed=!1,this.send_life=MAX_SEND_LIFE,this.recv_life=MAX_RECV_LIFE,this.keepAliveCb=d,this.cbId=0,this.responseCbId=0,this.cbs={},this.subs={},this.unsub={},this.connect_promise=this.connect(f,b)}}var _default=ChainWebSocket;exports.default=_default;
diff --git a/node_modules/meta1-vision-ws/lib/ConnectionManager.js b/node_modules/meta1-vision-ws/lib/ConnectionManager.js
index 9a39f1f..d1dcf86 100644
--- a/node_modules/meta1-vision-ws/lib/ConnectionManager.js
+++ b/node_modules/meta1-vision-ws/lib/ConnectionManager.js
@@ -1 +1 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var Apis=_interopRequireWildcard(require("./ApiInstances")),_ChainWebSocket=_interopRequireDefault(require("./ChainWebSocket"));function _interopRequireDefault(b){return b&&b.__esModule?b:{default:b}}function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var a={};if(null!=e)for(var b in e)if(Object.prototype.hasOwnProperty.call(e,b)){var c=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,b):{};c.get||c.set?Object.defineProperty(a,b,c):a[b]=e[b]}return a.default=e,a}function _defineProperty(d,a,b){return a in d?Object.defineProperty(d,a,{value:b,enumerable:!0,configurable:!0,writable:!0}):d[a]=b,d}class Manager{constructor({url:a,urls:b,autoFallback:c,closeCb:d,optionalApis:e,urlChangeCallback:f}){_defineProperty(this,"setCloseCb",b=>{this.closeCb=b}),_defineProperty(this,"logFailure",(e,a,b)=>{let c=b&&b.message?b.message:"";console.error(e,"Failed to connect to "+a+(c?" Error: "+JSON.stringify(c):""))}),_defineProperty(this,"_onClose",()=>{this.isConnected=!1,this.closeCb&&(this.closeCb(),this.setCloseCb(null)),this.autoFallback&&this.connectWithFallback()}),_defineProperty(this,"connect",async(d=!0,a=this.url)=>{try{let b=await Apis.instance(a,d,void 0,this.optionalApis,this._onClose).init_promise;return this.url=a,this.isConnected=!0,b}catch(b){throw await Apis.close(),b}}),_defineProperty(this,"connectWithFallback",async(f=!0,a=this.url,g=0,c=null,d=null)=>{if(g>this.urls.length)return d(new Error("Tried "+g+" connections, none of which worked: "+JSON.stringify(this.urls.concat(this.url))));try{return await this.connect(f,a)}catch(a){return this.urlChangeCallback&&this.urlChangeCallback(this.urls[g]),this.connectWithFallback(f,this.urls[g],g+1,c,d)}}),_defineProperty(this,"checkConnections",async(h="",a="",b,c)=>{let i={},d=this.urls.concat(this.url),e=d.map(async e=>{/* Use default timeout and no reconnecting-websocket */let b=new _ChainWebSocket.default(e,()=>{},void 0,!1);i[e]=new Date().getTime();try{await b.login(h,a);let c={[e]:new Date().getTime()-i[e]};return await b.close(),c}catch(c){return e===this.url?this.url=this.urls[0]:this.urls=this.urls.filter(a=>a!==e),void(await b.close())}});try{let c=await Promise.all(e),a=c.filter(a=>!!a).sort((b,c)=>Object.values(b)[0]-Object.values(c)[0]).reduce((d,b)=>{let c=Object.keys(b)[0];return d[c]=b[c],d},{});return console.log(`Checked ${c.length} connections, ${c.length-Object.keys(a).length} failed`),a}catch(d){return this.checkConnections(h,a,b,c)}}),this.url=a,this.urls=b.filter(b=>b!==a),this.autoFallback=c,this.closeCb=d,this.optionalApis=e||{},this.isConnected=!1,this.urlChangeCallback=f}static close(){return Apis.close()}}var _default=Manager;exports.default=_default;
\ No newline at end of file
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var Apis=_interopRequireWildcard(require("./ApiInstances")),_ChainWebSocket=_interopRequireDefault(require("./ChainWebSocket"));function _interopRequireDefault(b){return b&&b.__esModule?b:{default:b}}function _interopRequireWildcard(e){if(e&&e.__esModule)return e;var a={};if(null!=e)for(var b in e)if(Object.prototype.hasOwnProperty.call(e,b)){var c=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,b):{};c.get||c.set?Object.defineProperty(a,b,c):a[b]=e[b]}return a.default=e,a}function _defineProperty(d,a,b){return a in d?Object.defineProperty(d,a,{value:b,enumerable:!0,configurable:!0,writable:!0}):d[a]=b,d}class Manager{constructor(a){var h=this;let{url:i,urls:b,autoFallback:c,closeCb:d,optionalApis:e,urlChangeCallback:f}=a;_defineProperty(this,"setCloseCb",b=>{this.closeCb=b}),_defineProperty(this,"logFailure",(e,a,b)=>{let c=b&&b.message?b.message:"";console.error(e,"Failed to connect to "+a+(c?" Error: "+JSON.stringify(c):""))}),_defineProperty(this,"_onClose",()=>{this.isConnected=!1,this.closeCb&&(this.closeCb(),this.setCloseCb(null)),this.autoFallback&&this.connectWithFallback()}),_defineProperty(this,"connect",async function(){let d=!(0<arguments.length&&arguments[0]!==void 0)||arguments[0],a=1<arguments.length&&arguments[1]!==void 0?arguments[1]:h.url;try{let b=await Apis.instance(a,d,void 0,h.optionalApis,h._onClose).init_promise;return h.url=a,h.isConnected=!0,b}catch(b){throw await Apis.close(),b}}),_defineProperty(this,"connectWithFallback",async function(){let f=!(0<arguments.length&&arguments[0]!==void 0)||arguments[0],a=1<arguments.length&&arguments[1]!==void 0?arguments[1]:h.url,g=2<arguments.length&&arguments[2]!==void 0?arguments[2]:0,c=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,d=4<arguments.length&&arguments[4]!==void 0?arguments[4]:null;if(g>h.urls.length)return d(new Error("Tried "+g+" connections, none of which worked: "+JSON.stringify(h.urls.concat(h.url))));try{return await h.connect(f,a)}catch(a){return h.urlChangeCallback&&h.urlChangeCallback(h.urls[g]),h.connectWithFallback(f,h.urls[g],g+1,c,d)}}),_defineProperty(this,"checkConnections",async function(){let i=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"",a=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"",b=2<arguments.length?arguments[2]:void 0,c=3<arguments.length?arguments[3]:void 0,j={},d=h.urls.concat(h.url),e=d.map(async e=>{/* Use default timeout and no reconnecting-websocket */let b=new _ChainWebSocket.default(e,()=>{},void 0,!1);j[e]=new Date().getTime();try{await b.login(i,a);let c={[e]:new Date().getTime()-j[e]};return await b.close(),c}catch(c){return e===h.url?h.url=h.urls[0]:h.urls=h.urls.filter(a=>a!==e),void(await b.close())}});try{let c=await Promise.all(e),a=c.filter(a=>!!a).sort((b,c)=>Object.values(b)[0]-Object.values(c)[0]).reduce((d,b)=>{let c=Object.keys(b)[0];return d[c]=b[c],d},{});return console.log(`Checked ${c.length} connections, ${c.length-Object.keys(a).length} failed`),a}catch(d){return h.checkConnections(i,a,b,c)}}),this.url=i,this.urls=b.filter(a=>a!==i),this.autoFallback=c,this.closeCb=d,this.optionalApis=e||{},this.isConnected=!1,this.urlChangeCallback=f}static close(){return Apis.close()}}var _default=Manager;exports.default=_default;
\ No newline at end of file
